<h2>Overview</h2>
<p>Below are listed some of the basic design concepts of the Skeleton Framework. </p>
<h3>Containers</h3>
<p>Classes that act as Value Objects use a common interface that provides get(), set() and has() methods. </p>
<h3>Generic Service Locator</h3>
<p>The A_Locator class provides both registry and class loading functionalty. It is intended that the Locator is passed through the controller to inject commonly used objects and class loading into the application code. </p>
<h3>Dynamic Linkages for Lazy Loading</h3>
<p>To provide Lazy Loading of classes, the A_DL class holds a class name and path for later loading of a class and instantiation. </p>
<h3>Renderers and Rendering</h3>
<p>Any class that provides a render() method can act as a renderer. The Response and View use this polymorphism to enable renders to be attached in any arrangement. A number of classes provide a setRenderer() that allows the render to be set at run-time. </p>
<h3>Filters</h3>
<p>A standard interface is defined for filters. Filters provide a run() method. A FilterChain classes will run multiple filters on a value.</p>
<h3>Rules</h3>
<p>A standard interface are defined for rules to check if a condition is met and to provide an error message if it failed. Rules provide an isValid() method to check whether the rule passed or failed. A getErrorMsg() method gives access the error message if the rule failed. A Validator classe will run multiple rules to check an item in a container. </p>
<p></p>
